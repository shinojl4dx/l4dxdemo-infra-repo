# Architecture

## Overview

This repository provisions and manages Terraform CI infrastructure on AWS using GitHub Actions. It is a **platform repository** — it does not manage application infrastructure directly. Instead, it provides the secure, automated foundation that application teams build on top of.

---

## Design Principles

**Git as the sole source of truth.** No Terraform is ever run manually. Every infrastructure change begins as a Git commit.

**Ephemeral runners.** GitHub-hosted runners spin up per job and are destroyed when the job completes. There are no always-on servers, no persistent agents, no VMs to patch.

**No long-lived credentials.** CI authentication uses GitHub's OpenID Connect (OIDC) protocol. Runners receive short-lived AWS credentials that expire with the job. No secrets are stored anywhere.

**Remote, versioned, locked state.** Terraform state lives in S3 with versioning enabled. DynamoDB provides distributed locking, preventing concurrent applies from corrupting state.

**Developer isolation.** Developers do not need AWS credentials or local Terraform access. All infrastructure changes go through CI.

---

## System Diagram

```
┌─────────────────────────────────────────────────────────┐
│                     Developer Machine                   │
│                                                         │
│   git commit + git push ──────────────────────────────► │
└────────────────────────────────────────────────────────┬┘
                                                         │
                                          GitHub receives push
                                                         │
                                                         ▼
┌─────────────────────────────────────────────────────────┐
│                      GitHub Actions                     │
│                                                         │
│   Trigger: push to main                                 │
│   Runner: ubuntu-latest (ephemeral, GitHub-hosted)      │
│                                                         │
│   Step 1: Checkout repository                           │
│   Step 2: Request OIDC token from GitHub                │
│   Step 3: Exchange token for AWS credentials via STS    │
│   Step 4: terraform init  (pulls remote state)          │
│   Step 5: terraform validate                            │
│   Step 6: terraform plan  (saves plan file)             │
│   Step 7: terraform apply (applies saved plan)          │
│                                                         │
│   Runner exits → credentials expire → runner destroyed  │
└──────────────────────┬─────────────────────────────┬───┘
                       │                             │
              OIDC STS Exchange               State R/W + Locking
                       │                             │
                       ▼                             ▼
┌──────────────────────────────┐    ┌────────────────────────────────┐
│         AWS IAM              │    │         AWS S3 + DynamoDB       │
│                              │    │                                │
│  GitHub OIDC Provider        │    │  S3 Bucket (state)             │
│  IAM Role (assumed by CI)    │    │  ├── versioning: enabled       │
│  Trust: repo + branch scoped │    │  ├── encryption: AES256        │
│  Session duration: 1 hour    │    │  └── public access: blocked    │
│                              │    │                                │
│                              │    │  DynamoDB Table (locks)        │
│                              │    │  ├── billing: on-demand        │
│                              │    │  └── PITR: enabled             │
└──────────────────────────────┘    └────────────────────────────────┘
```

---

## Component Breakdown

### `install.sh`

A one-time, admin-run bootstrap script. It provisions platform infrastructure using local Terraform state (temporary), then installs the GitHub Actions workflow with real resource names embedded. After this runs, all future Terraform executes exclusively in CI.

### `uninstall.sh`

Reads `inventory.json` and destroys every resource `install.sh` created. Requires typing `DESTROY` to confirm. Refuses to run if a state lock is active.

### `inventory.json`

Auto-generated by `install.sh`. Never manually edited. Contains the authoritative record of all platform resource names and identifiers. Read by both CI and `uninstall.sh`.

### `terraform/backend/`

Terraform module run during bootstrap to create the S3 bucket and DynamoDB table. Uses local state (since the remote state backend doesn't exist yet). This is a bootstrapping paradox solved by running this module first, then migrating to the newly created backend.

### `terraform/iam/`

Terraform module run during bootstrap to create the GitHub OIDC identity provider and IAM role. The IAM role's trust policy is scoped to the specific GitHub org, repo, and branch.

### `terraform/providers.tf`

The root Terraform module that GitHub Actions runs. Uses a dynamic S3 backend (configured at `init` time). Add your application modules here.

### `.github/workflows/terraform-apply.yaml`

Generated by `install.sh` with live resource names embedded. Triggers on every push to `main`. Authenticates to AWS via OIDC, initializes the remote backend, and runs `terraform apply`.

---

## AWS Resource Map

| Resource | Name Pattern | Purpose |
|---|---|---|
| S3 Bucket | `tf-state-{repo}-{hash}` | Terraform state storage |
| DynamoDB Table | `tf-lock-{repo}-{hash}` | State locking |
| IAM Role | `github-actions-terraform-{repo}` | CI identity |
| IAM Policy | `{role-name}-policy` | Terraform permissions |
| OIDC Provider | `token.actions.githubusercontent.com` | GitHub trust |

Resource names include an 8-character hash derived from org + repo + account to prevent collisions across environments.

---

## State Backend Configuration

State backend values are **not hardcoded** in `terraform/providers.tf`. They are injected at `terraform init` time by the CI workflow:

```bash
terraform init \
  -backend-config="bucket=tf-state-myrepo-abc12345" \
  -backend-config="key=platform/terraform.tfstate" \
  -backend-config="region=us-east-1" \
  -backend-config="dynamodb_table=tf-lock-myrepo-abc12345" \
  -backend-config="encrypt=true"
```

This approach means the same `providers.tf` works across environments without modification.
